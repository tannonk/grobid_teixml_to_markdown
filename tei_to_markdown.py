#!/usr/bin/env python3
"""
Converts GROBID-generated TEI XML files to readable Markdown format

Example usage:

    python -m tei_to_markdown -i path/to/teixml/files -o path/to/output/dir

"""

import re
import argparse
import logging
from pathlib import Path
from typing import List, Dict, Optional
from string import punctuation

import xml.etree.ElementTree as ET
from tqdm import tqdm

def setup_logging(level: str = 'INFO') -> None:
    """
    Configure logging with specified level and format.
    
    Args:
        level: Logging level as string (DEBUG, INFO, WARNING, ERROR, CRITICAL)
    """
    numeric_level = getattr(logging, level.upper(), logging.INFO)
    
    # Create formatter with timestamp, level, and message
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # Configure root logger
    logger = logging.getLogger()
    logger.setLevel(numeric_level)
    
    # Remove existing handlers to avoid duplication
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
    
    # Create console handler
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    logging.info(f"Logging initialized at {level.upper()} level")


def set_args():
    parser = argparse.ArgumentParser(description='Convert TEI XML files to Markdown')
    parser.add_argument('-i', '--input_dir', type=Path, required=True, help='Input directory containing tei xml files generated by GROBID')
    parser.add_argument('-o', '--output_dir', type=Path, required=True, help='Output file or directory')
    parser.add_argument('-f', '--force', action='store_true', help='Force overwrite of existing files')
    
    # Logging configuration
    parser.add_argument('--log_level', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'], 
                       default='WARNING', help='Set the logging level (default: WARNING)')
    
    # Table and figure processing options (disabled by default)
    parser.add_argument('--include_tables', action='store_true', default=False, 
                       help='Include table processing in output (default: False)')
    parser.add_argument('--include_figures', action='store_true', default=False,
                       help='Include figure processing in output (default: False)')  
    parser.add_argument('--include_bib', action='store_true', default=False,
                       help='Include bibliography section in output (default: False)')
    parser.add_argument('--include_backmatter', action='store_true', default=False,
                       help='Include back matter section (acknowledgements, data availability, appendices) in output (default: False)')
    parser.add_argument('--table_format', choices=['markdown', 'placeholder'], default='markdown',
                       help='Format for table output (default: markdown)')
    parser.add_argument('--figure_format', choices=['detailed', 'placeholder'], default='detailed',
                       help='Format for figure output (default: detailed)')

    return parser.parse_args()


class TEIToMarkdownConverter:
    def __init__(self, include_tables: bool = False, include_figures: bool = False, 
                 table_format: str = 'markdown', figure_format: str = 'detailed',
                 include_bib: bool = False, include_backmatter: bool = False):
        """
        Initialize TEI to Markdown converter with processing options.
        
        Args:
            include_tables: Whether to process tables (default: False)
            include_figures: Whether to process figures (default: False)  
            table_format: Format for table output ('markdown' or 'placeholder')
            figure_format: Format for figure output ('detailed' or 'placeholder')
            include_bib: Whether to process references (default: False)
            include_backmatter: Whether to process back matter section (default: False)
        """
        # Initialize logger for this converter instance
        self.logger = logging.getLogger(self.__class__.__name__)
        
        # Define TEI namespace
        self.ns = {'tei': 'http://www.tei-c.org/ns/1.0'}
        
        # Processing configuration
        self.include_tables = include_tables
        self.include_figures = include_figures
        self.table_format = table_format
        self.figure_format = figure_format
        self.include_bib = include_bib
        self.include_backmatter = include_backmatter
        
        # Log configuration
        self.logger.info(f"Initialized TEI converter with options: tables={include_tables}, "
                        f"figures={include_figures}, bibliography={include_bib}, "
                        f"backmatter={include_backmatter}")
        self.logger.debug(f"Table format: {table_format}, Figure format: {figure_format}")
        
    def parse_tei_file(self, file_path: str) -> str:
        """Parse a TEI XML file and convert to Markdown"""
        try:
            tree = ET.parse(file_path)
            root = tree.getroot()
            
            markdown_content = []
            
            # Extract title
            title = self.extract_title(root)
            if title:
                markdown_content.append(f"## {title}\n")
            
            # # Extract authors
            # authors = self.extract_authors(root)
            # if authors:
            #     markdown_content.append(f"**Authors:** {', '.join(authors)}\n")
            
            # # Extract DOI if available
            # doi = self.extract_doi(root)
            # if doi:
            #     markdown_content.append(f"**DOI:** {doi}\n")
            
            
            # Extract abstract
            abstract = self.extract_abstract(root)
            if abstract:
                markdown_content.append(f"## Abstract\n\n{abstract}\n")

            # Extract keywords
            keywords = self.extract_keywords(root)
            if keywords:
                markdown_content.append(f"## Keywords\n\n{keywords}\n")
            
            # Extract main body text
            body_text = self.extract_body(root)
            if body_text:
                markdown_content.append(body_text)
            
            # Extract standalone figures and tables if requested
            if self.include_figures or self.include_tables:
                figures = self.extract_figures(root)
                if figures:
                    markdown_content.append("\n\n## Figures and Tables\n")
                    markdown_content.append(figures)
            
            # Extract back matter if requested
            if self.include_backmatter:
                back_content = self.extract_back(root)
                if back_content:
                    markdown_content.append("\n\n")
                    markdown_content.append(back_content)
            
            # Extract references if requested
            if self.include_bib:
                references = self.extract_references(root)
                if references:
                    markdown_content.append("\n\n## References\n")
                    for i, ref in enumerate(references, 1):
                        markdown_content.append(f"{i}. {ref}")
                    markdown_content.append("")
            
            result = "\n".join(markdown_content)
            self.logger.info(f"Successfully converted TEI file to Markdown ({len(result)} characters)")
            return result
            
        except ET.ParseError as e:
            self.logger.error(f"XML parsing error in {file_path}: {e}")
            raise Exception(f"Error parsing XML file {file_path}: {e}")
        except FileNotFoundError as e:
            self.logger.error(f"File not found: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error processing {file_path}: {e}")
            raise Exception(f"Error processing file {file_path}: {e}")
    
    def _validate_tei_structure(self, root: ET.Element) -> None:
        """
        Validate basic TEI XML structure and log findings.
        
        Args:
            root: XML root element
            
        Raises:
            ValueError: If critical TEI structure is missing
        """
        # Check if root is TEI element
        if not root.tag.endswith('TEI'):
            self.logger.warning(f"Root element is not TEI: {root.tag}")
        
        # Check for TEI namespace
        if 'http://www.tei-c.org/ns/1.0' not in str(root.nsmap) if hasattr(root, 'nsmap') else True:
            self.logger.debug("TEI namespace validation skipped (using ElementTree)")
        
        # Check for essential TEI structure
        tei_header = root.find('.//tei:teiHeader', self.ns)
        tei_text = root.find('.//tei:text', self.ns)
        
        if tei_header is None:
            self.logger.warning("No teiHeader found - document may lack metadata")
        else:
            self.logger.debug("teiHeader found")
            
        if tei_text is None:
            self.logger.warning("No text element found - document may lack main content")
            raise ValueError("Invalid TEI structure: missing text element")
        else:
            self.logger.debug("text element found")
            
        # Log document structure overview
        body = root.find('.//tei:text/tei:body', self.ns)
        if body is not None:
            sections = body.findall('tei:div', self.ns)
            self.logger.debug(f"Document body contains {len(sections)} main sections")
        
        figures = root.findall('.//tei:figure', self.ns)
        self.logger.debug(f"Document contains {len(figures)} figures/tables")
        
        refs = root.findall('.//tei:back//tei:biblStruct', self.ns)
        self.logger.debug(f"Document contains {len(refs)} references")
    
    def extract_title(self, root: ET.Element) -> Optional[str]:
        """
        Extract the main title from TEI header.
        
        Args:
            root: TEI XML root element
            
        Returns:
            Main title string or None if not found
        """
        title_elem = root.find('.//tei:titleStmt/tei:title[@level="a"][@type="main"]', self.ns)
        if title_elem is not None and title_elem.text:
            title = title_elem.text.strip()
            self.logger.debug(f"Extracted title: '{title[:50]}{'...' if len(title) > 50 else ''}'")
            return title
        
        self.logger.warning("No main title found in document")
        return None
    
    def extract_authors(self, root: ET.Element) -> List[str]:
        """Extract author names"""
        authors = []
        author_elems = root.findall('.//tei:analytic/tei:author/tei:persName', self.ns)
        
        for author_elem in author_elems:
            name_parts = []
            
            # Extract forename(s)
            forenames = author_elem.findall('tei:forename', self.ns)
            for forename in forenames:
                if forename.text:
                    name_parts.append(forename.text.strip())
            
            # Extract surname
            surname_elem = author_elem.find('tei:surname', self.ns)
            if surname_elem is not None and surname_elem.text:
                name_parts.append(surname_elem.text.strip())
            
            if name_parts:
                authors.append(' '.join(name_parts))

        if not authors:
            self.logger.warning("No authors found in document")

        return authors
    
    def extract_doi(self, root: ET.Element) -> Optional[str]:
        """Extract DOI"""
        doi_elem = root.find('.//tei:idno[@type="DOI"]', self.ns)
        if doi_elem is not None and doi_elem.text:
            return doi_elem.text.strip()
        return None
    
    def extract_keywords(self, root: ET.Element) -> Optional[str]:
        """
        Extract keywords from TEI document.
        
        Args:
            root: TEI XML root element
            
        Returns:
            Keywords string or None if not found
        """
        keywords_elem = root.find('.//tei:keywords', self.ns)
        if keywords_elem is not None and keywords_elem.text:
            keywords = keywords_elem.text.strip()
            self.logger.debug(f"Extracted keywords: {keywords[:100]}{'...' if len(keywords) > 100 else ''}")
            return keywords
        
        self.logger.debug("No keywords found in document")
        return None
    
    def extract_abstract(self, root: ET.Element) -> Optional[str]:
        """
        Extract abstract text from TEI document.
        
        Args:
            root: TEI XML root element
            
        Returns:
            Abstract text or None if not found
        """
        abstract_div = root.find('.//tei:abstract/tei:div', self.ns)
        if abstract_div is not None:
            abstract = self.extract_text_content(abstract_div)
            if abstract:
                self.logger.debug(f"Extracted abstract ({len(abstract)} characters)")
                return abstract
        
        self.logger.debug("No abstract found in document")
        return None
    
    def extract_body(self, root: ET.Element) -> str:
        """
        Extract main body content with section structure.
        
        Args:
            root: TEI XML root element
            
        Returns:
            Formatted body text as markdown
        """
        body_elem = root.find('.//tei:text/tei:body', self.ns)
        if body_elem is None:
            self.logger.warning("No body element found in TEI document")
            return ""
        
        content = []
        sections = body_elem.findall('tei:div', self.ns)
        self.logger.debug(f"Processing {len(sections)} body sections")
        
        # Process each div (section) in the body
        for i, div in enumerate(sections, 1):
            self.logger.debug(f"Processing body section {i}/{len(sections)}")
            section_content = self.process_section(div)
            if section_content:
                content.append(section_content)
            else:
                self.logger.debug(f"Section {i} produced no content")
        
        result = "\n\n".join(content)
        self.logger.debug(f"Body extraction complete: {len(result)} characters from {len(content)} sections")
        return result
    
    def extract_figures(self, root: ET.Element) -> str:
        """Extract standalone figures and tables from document"""
        content = []
        
        # Find all figure elements in the document (typically after body content)
        figures = root.findall('.//tei:figure', self.ns)
        
        for figure in figures:
            figure_content = self.process_figure(figure)
            if figure_content:
                content.append(figure_content)

        self.logger.debug(f"Figure extraction complete: {len(content)} figures found")

        return "\n\n".join(content) if content else ""
    
    def extract_back(self, root: ET.Element) -> str:
        """
        Extract back matter content (acknowledgement, data availability, appendices, etc.)
        
        Args:
            root: TEI XML root element
            
        Returns:
            Formatted back matter sections or empty string if none found
        """
        content = []
        
        # Find the back element
        back_elem = root.find('.//tei:text/tei:back', self.ns)
        if back_elem is None:
            return ""
        
        # Process different types of back matter
        for div in back_elem.findall('tei:div', self.ns):
            div_type = div.get('type')
            
            if div_type == 'references':
                # References are handled separately by extract_references
                continue
            else:
                # Handle other types with generic processing
                content.append(self.process_backmatter(div))
        
        # Process funding information if present
        funding_elem = back_elem.find('tei:listOrg[@type="funding"]', self.ns)
        if funding_elem is not None:
            funding_content = self.process_funding_section(funding_elem)
            if funding_content:
                content.append(funding_content)
        
        return "\n\n".join(content) if content else ""
    
    def process_backmatter(self, div: ET.Element) -> str:
        """Process a back matter section with consistent formatting"""
        content = []
                
        # Process nested divs and content
        for child_div in div.findall('.//tei:div', self.ns):
            # Extract section header if present
            head_elem = child_div.find('tei:head', self.ns)
            if head_elem is not None:
                header_text = self.clean_header_text(self.extract_text_content(head_elem))
                if header_text:
                    content.append(f"## {header_text}")

            # Extract paragraphs
            for p in child_div.findall('tei:p', self.ns):
                para_text = self.extract_text_content(p)
                if para_text:
                    content.append(para_text)
        
        # Also handle direct paragraphs in the main div
        for p in div.findall('tei:p', self.ns):
            para_text = self.extract_text_content(p)
            if para_text:
                content.append(para_text)
        
        return "\n\n".join(content) if len(content) > 1 else ""
    
    def process_funding_section(self, funding_elem: ET.Element) -> str:
        """Process funding information"""
        content = ["## Funding Information"]
        
        # Extract funding organizations
        for org in funding_elem.findall('tei:org', self.ns):
            org_info = []
            
            # Get grant number
            grant_num = org.find('tei:idno[@type="grant-number"]', self.ns)
            if grant_num is not None and grant_num.text:
                org_info.append(f"Grant Number: {grant_num.text.strip()}")
            
            if org_info:
                content.append("- " + ", ".join(org_info))
        
        return "\n\n".join(content) if len(content) > 1 else ""
    
    def process_section(self, div: ET.Element) -> str:
        """
        Process a section div element, handling all child elements in document order.
        
        Args:
            div: TEI div element to process
            
        Returns:
            Formatted section content as markdown string
        """
        content = []
        
        # Process all children in document order to preserve structure
        for child in div:
            child_tag = child.tag.split('}')[-1] if '}' in child.tag else child.tag
            
            if child_tag == 'head':
                # Section header
                header_text = self.clean_header_text(self.extract_text_content(child))
                if header_text:
                    content.append(f"## {header_text}")
                    self.logger.debug(f"Processed section header: {header_text[:50]}...")
            
            elif child_tag == 'p':
                # Paragraph
                para_text = self.extract_text_content(child)
                if para_text:
                    content.append(para_text)
                    self.logger.debug(f"Processed paragraph ({len(para_text)} chars)")
            
            elif child_tag == 'formula':
                # Mathematical formula - direct child of div
                formula_content = self.process_formula(child)
                if formula_content:
                    content.append(formula_content)
                    self.logger.debug("Processed formula element")
            
            elif child_tag == 'div':
                # Nested subsection
                subsection_content = self.process_section(child)
                if subsection_content:
                    content.append(subsection_content)
                    self.logger.debug("Processed nested div section")
            
            elif child_tag == 'list':
                # List elements
                list_content = self.process_list(child)
                if list_content:
                    content.append(list_content)
                    self.logger.debug("Processed list element")
            
            elif child_tag == 'quote':
                # Block quotations
                quote_content = self.process_quote(child)
                if quote_content:
                    content.append(quote_content)
                    self.logger.debug("Processed quote element")
            
            elif child_tag == 'table':
                # Tables (less common as direct children, but possible)
                table_content = self.process_table(child)
                if table_content:
                    content.append(table_content)
                    self.logger.debug("Processed table element")
            
            elif child_tag == 'figure':
                # Figures (less common as direct children, but possible)  
                figure_content = self.process_figure(child)
                if figure_content:
                    content.append(figure_content)
                    self.logger.debug("Processed figure element")
            
            else:
                # Fallback for any other element types - extract text content
                fallback_text = self.extract_text_content(child)
                if fallback_text:
                    content.append(fallback_text)
                    self.logger.debug(f"Processed unknown element '{child_tag}' as text ({len(fallback_text)} chars)")
        
        result = "\n\n".join(content)
        self.logger.debug(f"Section processing complete: {len(result)} characters from {len(content)} elements")
        return result
    
    def process_formula(self, formula_elem: ET.Element) -> str:
        """
        Process mathematical formula elements as standalone blocks.
        
        Args:
            formula_elem: TEI formula element
            
        Returns:
            Formatted formula as LaTeX-style math block
        """
        # Extract formula content - handle both text and child elements (like label)
        formula_text = ""
        label_text = ""
        
        # Get direct text content
        if formula_elem.text:
            formula_text += formula_elem.text
        
        # Process child elements
        for child in formula_elem:
            child_tag = child.tag.split('}')[-1] if '}' in child.tag else child.tag
            
            if child_tag == 'label':
                # Formula label (like equation number)
                if child.text:
                    label_text = child.text.strip()
            else:
                # Other content - add to formula text
                if child.text:
                    formula_text += child.text
            
            # Add tail text after child element
            if child.tail:
                formula_text += child.tail
        
        # Clean up the formula text
        formula_text = formula_text.strip()
        
        if not formula_text:
            self.logger.warning("Formula element found but no content extracted")
            return ""
        
        # Format as LaTeX math block
        if label_text:
            result = f"$${formula_text}$$ {label_text}"
            self.logger.debug(f"Processed labeled formula: {formula_text[:50]}... ({label_text})")
        else:
            result = f"$${formula_text}$$"
            self.logger.debug(f"Processed unlabeled formula: {formula_text[:50]}...")
        
        return result
    
    def process_list(self, list_elem: ET.Element) -> str:
        """
        Process TEI list elements.
        
        Args:
            list_elem: TEI list element
            
        Returns:
            Formatted markdown list
        """
        items = []
        list_type = list_elem.get('type', 'unordered')
        
        # Process list items
        for item in list_elem.findall('tei:item', self.ns):
            item_text = self.extract_text_content(item)
            if item_text:
                if list_type == 'ordered':
                    items.append(f"1. {item_text}")
                else:
                    items.append(f"- {item_text}")
        
        result = "\n".join(items) if items else ""
        if result:
            self.logger.debug(f"Processed {list_type} list with {len(items)} items")
        
        return result
    
    def process_quote(self, quote_elem: ET.Element) -> str:
        """
        Process TEI quote elements as block quotes.
        
        Args:
            quote_elem: TEI quote element
            
        Returns:
            Formatted markdown block quote
        """
        quote_text = self.extract_text_content(quote_elem)
        
        if not quote_text:
            return ""
        
        # Format as markdown block quote
        lines = quote_text.split('\n')
        quoted_lines = [f"> {line}" if line.strip() else ">" for line in lines]
        result = "\n".join(quoted_lines)
        
        self.logger.debug(f"Processed quote block ({len(quote_text)} characters)")
        return result
    
    def extract_text_content(self, element: ET.Element) -> str:
        """Extract clean text content from an element, handling references and formatting"""
        if element is None:
            return ""
        
        # Get all text content
        text_parts = []
        
        def extract_recursive(elem):
            if elem.text:
                text_parts.append(elem.text)
            
            for child in elem:
                extract_recursive(child)
                
                if child.tail:
                    text_parts.append(child.tail)
        
        extract_recursive(element)
        
        # Join and clean up the text
        text = ''.join(text_parts)
        
        # Clean up whitespace
        text = re.sub(r'\s+', ' ', text)
        text = re.sub(r'\n\s*\n', '\n\n', text)
        
        return text.strip()
    
    def process_table(self, table_elem: ET.Element) -> str:
        """
        Process table elements with full structure preservation.
        
        Args:
            table_elem: TEI XML element containing table or figure[@type="table"]
            
        Returns:
            Formatted markdown table or placeholder based on configuration
        """
        self.logger.debug("Processing table element")
        
        # Check configuration - use placeholder if table processing is disabled
        if not self.include_tables or self.table_format == 'placeholder':
            self.logger.debug("Table processing disabled, using placeholder")
            return "\n[TABLE - See original document]\n"
            
        try:
            content = []
            
            # Extract table metadata
            head = table_elem.find('tei:head', self.ns)
            label = table_elem.find('tei:label', self.ns)
            figDesc = table_elem.find('tei:figDesc', self.ns)
            
            # Log table metadata discovery
            self.logger.debug(f"Table metadata - Head: {head is not None}, "
                            f"Label: {label is not None}, Description: {figDesc is not None}")
            
            # Create table header
            if head is not None and head.text:
                table_title = head.text.strip()
                if label is not None and label.text:
                    content.append(f"## Table {label.text.strip()}: {table_title}")
                    self.logger.debug(f"Table with label and title: {label.text.strip()}")
                else:
                    content.append(f"## {table_title}")
                    self.logger.debug(f"Table with title only: {table_title[:50]}...")
            
            # Add description if available
            if figDesc is not None:
                desc = self.extract_text_content(figDesc)
                if desc:
                    content.append(f"\n**Description:** {desc}\n")
                    self.logger.debug(f"Added table description ({len(desc)} characters)")
            
            # Process actual table data
            table_data = table_elem.find('tei:table', self.ns)
            if table_data is not None:
                rows = table_data.findall('tei:row', self.ns)
                self.logger.debug(f"Found table with {len(rows)} rows")
                if rows:
                    markdown_table = self.convert_table_to_markdown(rows)
                    if markdown_table:
                        content.append(markdown_table)
                        self.logger.debug("Successfully converted table to markdown")
                    else:
                        content.append("\n[TABLE - Structure could not be parsed]\n")
                        self.logger.warning("Table structure conversion failed")
                else:
                    content.append("\n[TABLE - No rows found]\n")
                    self.logger.warning("Table element found but no rows present")
            else:
                content.append("\n[TABLE - No table data found]\n")
                self.logger.warning("No tei:table element found in figure[@type='table']")
            
            result = "\n".join(content) if content else "\n[TABLE - Structure could not be parsed]\n"
            self.logger.debug(f"Table processing complete ({len(result)} characters)")
            return result
            
        except Exception as e:
            # Fallback to placeholder on any error
            self.logger.error(f"Error processing table: {e}")
            return f"\n[TABLE - Processing error: {str(e)}]\n"
    
    def convert_table_to_markdown(self, rows: list) -> str:
        """
        Convert TEI table rows to markdown table format.
        
        Args:
            rows: List of TEI row elements
            
        Returns:
            Formatted markdown table string or empty string if conversion fails
        """
        self.logger.debug(f"Converting {len(rows)} table rows to markdown")
        
        try:
            markdown_rows = []
            max_cols = 0
            
            for i, row in enumerate(rows):
                cells = row.findall('tei:cell', self.ns)
                cell_texts = []
                
                self.logger.debug(f"Row {i+1}: {len(cells)} cells")
                
                for j, cell in enumerate(cells):
                    cell_text = self.extract_text_content(cell).strip()
                    # Escape pipe characters in cell content to prevent markdown table corruption
                    cell_text = cell_text.replace('|', '\\|')
                    # Replace newlines with spaces to keep table structure
                    cell_text = cell_text.replace('\n', ' ')
                    cell_texts.append(cell_text)
                    
                    if len(cell_text) > 50:  # Log long cell content
                        self.logger.debug(f"Cell {j+1} content truncated: '{cell_text[:50]}...'")
                
                # Track maximum columns for validation
                max_cols = max(max_cols, len(cell_texts))
                
                # Create markdown table row
                if cell_texts:
                    markdown_rows.append('| ' + ' | '.join(cell_texts) + ' |')
                    
                    # Add separator after header row (first row)
                    if i == 0:
                        separator = '|' + '---|' * len(cell_texts)
                        markdown_rows.append(separator)
                else:
                    self.logger.warning(f"Row {i+1} has no cell content")
            
            if markdown_rows:
                self.logger.debug(f"Successfully converted table: {len(markdown_rows)} markdown rows, "
                                f"max {max_cols} columns")
            else:
                self.logger.warning("Table conversion produced no output rows")
            
            return '\n'.join(markdown_rows) if markdown_rows else ""
            
        except Exception as e:
            # Return empty string on conversion error - caller will handle fallback
            self.logger.error(f"Error in table conversion: {e}")
            return ""
    
    def process_figure(self, figure_elem: ET.Element) -> str:
        """
        Process figure elements with complete metadata extraction.
        
        Args:
            figure_elem: TEI XML element containing figure data
            
        Returns:
            Formatted figure information or placeholder based on configuration
        """
        # Check if this is actually a table (GROBID uses figure[@type="table"])
        if figure_elem.get('type') == 'table':
            self.logger.debug("Figure element is actually a table, delegating to table processor")
            return self.process_table(figure_elem)
        
        self.logger.debug("Processing figure element")
        
        # Check configuration - use placeholder if figure processing is disabled  
        if not self.include_figures or self.figure_format == 'placeholder':
            self.logger.debug("Figure processing disabled, using placeholder")
            return "\n[FIGURE - See original document]\n"
            
        try:
            content = []
            
            # Extract figure metadata
            head = figure_elem.find('tei:head', self.ns)
            label = figure_elem.find('tei:label', self.ns)
            figDesc = figure_elem.find('tei:figDesc', self.ns)
            graphic = figure_elem.find('tei:graphic', self.ns)
            
            # Log figure metadata discovery
            self.logger.debug(f"Figure metadata - Head: {head is not None}, "
                            f"Label: {label is not None}, Description: {figDesc is not None}, "
                            f"Graphic: {graphic is not None}")
            
            # Create figure header
            if head is not None and head.text:
                figure_title = head.text.strip()
                if label is not None and label.text:
                    content.append(f"## Figure {label.text.strip()}: {figure_title}")
                    self.logger.debug(f"Figure with label and title: {label.text.strip()}")
                else:
                    content.append(f"## {figure_title}")
                    self.logger.debug(f"Figure with title only: {figure_title[:50]}...")
            elif label is not None and label.text:
                content.append(f"## Figure {label.text.strip()}")
                self.logger.debug(f"Figure with label only: {label.text.strip()}")
            
            # Add image reference if available
            if graphic is not None:
                image_url = graphic.get('url', '')
                if image_url:
                    alt_text = f"Figure {label.text if label is not None and label.text else ''}"
                    content.append(f"\n![{alt_text}]({image_url})\n")
                    self.logger.debug(f"Added figure image reference: {image_url}")
                else:
                    self.logger.warning("Graphic element found but no URL attribute")
            else:
                self.logger.debug("No graphic element found for figure")
            
            # Add description
            if figDesc is not None:
                desc = self.extract_text_content(figDesc)
                if desc:
                    content.append(f"**Description:** {desc}")
                    self.logger.debug(f"Added figure description ({len(desc)} characters)")
                else:
                    self.logger.warning("Figure description element found but no content extracted")
            
            result = "\n".join(content) if content else "\n[FIGURE - No content found]\n"
            self.logger.debug(f"Figure processing complete ({len(result)} characters)")
            return result
            
        except Exception as e:
            # Fallback to placeholder on any error
            self.logger.error(f"Error processing figure: {e}")
            return f"\n[FIGURE - Processing error: {str(e)}]\n"
    
    def extract_references(self, root: ET.Element) -> List[str]:
        """
        Extract bibliography references from TEI back matter.
        
        Args:
            root: TEI XML root element
            
        Returns:
            List of formatted reference strings
        """
        references = []
        
        # Look for biblStruct elements in the back matter
        bibl_structs = root.findall('.//tei:back//tei:biblStruct', self.ns)
        self.logger.debug(f"Found {len(bibl_structs)} bibliography entries")
        
        for i, bibl in enumerate(bibl_structs, 1):
            ref_text = self.format_reference(bibl)
            if ref_text:
                references.append(ref_text)
                self.logger.debug(f"Processed reference {i}: {ref_text[:80]}{'...' if len(ref_text) > 80 else ''}")
            else:
                self.logger.warning(f"Reference {i} could not be formatted (missing required elements)")
        
        self.logger.info(f"Successfully extracted {len(references)} references")
        return references
    
    def format_reference(self, bibl_struct: ET.Element) -> str:
        """Format a single bibliographic reference"""
        parts = []
        
        # Extract authors
        authors = []
        author_elems = bibl_struct.findall('.//tei:author/tei:persName', self.ns)
        for author in author_elems:
            name = self.extract_text_content(author)
            if name:
                authors.append(name)
        
        if authors:
            if len(authors) == 1:
                parts.append(authors[0])
            elif len(authors) <= 3:
                parts.append(', '.join(authors[:-1]) + ' and ' + authors[-1])
            else:
                parts.append(authors[0] + ' et al.')
        
        # Extract title
        title_elem = bibl_struct.find('.//tei:title', self.ns)
        if title_elem is not None:
            title = self.extract_text_content(title_elem)
            if title:
                parts.append(f'"{title}"')
        
        # Extract journal/publication info
        monogr = bibl_struct.find('.//tei:monogr', self.ns)
        if monogr is not None:
            journal_elem = monogr.find('tei:title', self.ns)
            if journal_elem is not None:
                journal = self.extract_text_content(journal_elem)
                if journal:
                    parts.append(f"*{journal}*")
            
            # Extract publication year
            date_elem = monogr.find('.//tei:date', self.ns)
            if date_elem is not None and date_elem.get('when'):
                year = date_elem.get('when')
                parts.append(f"({year})")
        
        return '. '.join(parts) + '.' if parts else ""

    @staticmethod
    def clean_header_text(header_text: str) -> str:
        """Clean up the header text by removing unwanted whitespace and punctuation."""
        return header_text.strip().strip(punctuation).strip()


def main():
    """
    Main entry point for the CLI application.
    
    Sets up logging, processes command line arguments, and converts TEI files to Markdown.
    """
    args = set_args()
    
    # Setup logging with user-specified level
    setup_logging(args.log_level)
    logger = logging.getLogger(__name__)
    
    logger.info("Starting TEI to Markdown conversion")
    logger.info(f"Input directory: {args.input_dir}")
    logger.info(f"Output directory: {args.output_dir}")
    logger.info(f"Processing options: tables={args.include_tables}, figures={args.include_figures}, "
               f"bibliography={args.include_bib}, backmatter={args.include_backmatter}")
    
    # Create converter with user configuration
    converter = TEIToMarkdownConverter(
        include_tables=args.include_tables,
        include_figures=args.include_figures,
        table_format=args.table_format,
        figure_format=args.figure_format,
        include_bib=args.include_bib,
        include_backmatter=args.include_backmatter
    )
    
    # Find input files
    input_files = list(args.input_dir.glob('*.xml'))
    logger.info(f"Found {len(input_files)} XML files in input directory")

    if not input_files:
        logger.error(f"No XML files found in {args.input_dir}")
        raise RuntimeError(f"No XML files found in {args.input_dir}")

    # Setup output directory
    output_dir = Path(args.output_dir) if args.output_dir else args.input_dir
    output_dir.mkdir(parents=True, exist_ok=True)
    logger.debug(f"Output directory created/verified: {output_dir}")
    
    # Process files with detailed logging
    successful_conversions = 0
    failed_conversions = 0
    skipped_files = 0
    
    for input_file in tqdm(input_files, desc="Processing TEI files", total=len(input_files)):
        output_file = output_dir / input_file.name.replace('.tei.xml', '.md')
        
        if output_file.exists() and not args.force:
            logger.info(f"Skipping {input_file.name} (output exists, use --force to overwrite)")
            skipped_files += 1
            continue
        
        try:
            logger.debug(f"Converting {input_file.name}")
            markdown_content = converter.parse_tei_file(str(input_file))
            
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(markdown_content)
            
            logger.info(f"Successfully converted {input_file.name} -> {output_file.name} "
                       f"({len(markdown_content)} characters)")
            successful_conversions += 1
            
        except Exception as e:
            logger.error(f"Failed to process {input_file.name}: {e}")
            failed_conversions += 1

    # Final summary
    logger.info(f"Conversion complete: {successful_conversions} successful, "
               f"{failed_conversions} failed, {skipped_files} skipped")
    
    if failed_conversions > 0:
        logger.warning(f"{failed_conversions} files failed to convert - check error messages above")
    
    print(f"Converted {successful_conversions}/{len(input_files)} files.")
    if failed_conversions > 0:
        print(f"Warning: {failed_conversions} files failed to convert.")
    if skipped_files > 0:
        print(f"Skipped {skipped_files} existing files (use --force to overwrite).")


if __name__ == "__main__":
    main()
