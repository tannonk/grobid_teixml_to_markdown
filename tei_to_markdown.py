#!/usr/bin/env python3
"""
Converts GROBID-generated TEI XML files to readable Markdown format

Example usage:

    python -m format_conversion.tei_to_markdown -i path/to/teixml/files -o path/to/output/dir

"""

import re
import argparse
from pathlib import Path
from typing import List, Dict, Optional

import xml.etree.ElementTree as ET
from tqdm import tqdm

def set_args():
    parser = argparse.ArgumentParser(description='Convert TEI XML files to Markdown')
    parser.add_argument('-i', '--input_dir', type=Path, required=True, help='Input directory containing tei xml files generated by GROBID')
    parser.add_argument('-o', '--output_dir', type=Path, required=True, help='Output file or directory')
    parser.add_argument('-f', '--force', action='store_true', help='Force overwrite of existing files')
    
    # Table and figure processing options (disabled by default)
    parser.add_argument('--include_tables', action='store_true', default=False, 
                       help='Include table processing in output (default: False)')
    parser.add_argument('--include_figures', action='store_true', default=False,
                       help='Include figure processing in output (default: False)')  
    parser.add_argument('--include_bib', action='store_true', default=False,
                       help='Include bibliography section in output (default: False)')
    parser.add_argument('--include_backmatter', action='store_true', default=False,
                       help='Include back matter section (acknowledgements, data availability, appendices) in output (default: False)')
    parser.add_argument('--table_format', choices=['markdown', 'placeholder'], default='markdown',
                       help='Format for table output (default: markdown)')
    parser.add_argument('--figure_format', choices=['detailed', 'placeholder'], default='detailed',
                       help='Format for figure output (default: detailed)')

    return parser.parse_args()


class TEIToMarkdownConverter:
    def __init__(self, include_tables: bool = False, include_figures: bool = False, 
                 table_format: str = 'markdown', figure_format: str = 'detailed',
                 include_bib: bool = False, include_backmatter: bool = False):
        """
        Initialize TEI to Markdown converter with processing options.
        
        Args:
            include_tables: Whether to process tables (default: False)
            include_figures: Whether to process figures (default: False)  
            table_format: Format for table output ('markdown' or 'placeholder')
            figure_format: Format for figure output ('detailed' or 'placeholder')
            include_bib: Whether to process references (default: False)
            include_backmatter: Whether to process back matter section (default: False)
        """
        # Define TEI namespace
        self.ns = {'tei': 'http://www.tei-c.org/ns/1.0'}
        
        # Processing configuration
        self.include_tables = include_tables
        self.include_figures = include_figures
        self.table_format = table_format
        self.figure_format = figure_format
        self.include_bib = include_bib
        self.include_backmatter = include_backmatter
        
    def parse_tei_file(self, file_path: str) -> str:
        """Parse a TEI XML file and convert to Markdown"""
        try:
            tree = ET.parse(file_path)
            root = tree.getroot()
            
            markdown_content = []
            
            # Extract title
            title = self.extract_title(root)
            if title:
                markdown_content.append(f"# {title}\n")
            
            # # Extract authors
            # authors = self.extract_authors(root)
            # if authors:
            #     markdown_content.append(f"**Authors:** {', '.join(authors)}\n")
            
            # # Extract DOI if available
            # doi = self.extract_doi(root)
            # if doi:
            #     markdown_content.append(f"**DOI:** {doi}\n")
            
            
            # Extract abstract
            abstract = self.extract_abstract(root)
            if abstract:
                markdown_content.append(f"## Abstract\n\n{abstract}\n")

            # Extract keywords
            keywords = self.extract_keywords(root)
            if keywords:
                markdown_content.append(f"**Keywords:** {keywords}\n")
            
            # Extract main body text
            body_text = self.extract_body(root)
            if body_text:
                markdown_content.append(body_text)
            
            # Extract standalone figures and tables if requested
            if self.include_figures or self.include_tables:
                figures = self.extract_figures(root)
                if figures:
                    markdown_content.append("\n\n## Figures and Tables\n")
                    markdown_content.append(figures)
            
            # Extract back matter if requested
            if self.include_backmatter:
                back_content = self.extract_back(root)
                if back_content:
                    markdown_content.append("\n\n")
                    markdown_content.append(back_content)
            
            # Extract references if requested
            if self.include_bib:
                references = self.extract_references(root)
                if references:
                    markdown_content.append("\n\n## References\n")
                    for i, ref in enumerate(references, 1):
                        markdown_content.append(f"{i}. {ref}")
                    markdown_content.append("")
            
            return "\n".join(markdown_content)
            
        except ET.ParseError as e:
            raise Exception(f"Error parsing XML file: {e}")
        except Exception as e:
            raise Exception(f"Error processing file: {e}")
    
    def extract_title(self, root: ET.Element) -> Optional[str]:
        """Extract the main title from TEI header"""
        title_elem = root.find('.//tei:titleStmt/tei:title[@level="a"][@type="main"]', self.ns)
        if title_elem is not None and title_elem.text:
            return title_elem.text.strip()
        return None
    
    def extract_authors(self, root: ET.Element) -> List[str]:
        """Extract author names"""
        authors = []
        author_elems = root.findall('.//tei:analytic/tei:author/tei:persName', self.ns)
        
        for author_elem in author_elems:
            name_parts = []
            
            # Extract forename(s)
            forenames = author_elem.findall('tei:forename', self.ns)
            for forename in forenames:
                if forename.text:
                    name_parts.append(forename.text.strip())
            
            # Extract surname
            surname_elem = author_elem.find('tei:surname', self.ns)
            if surname_elem is not None and surname_elem.text:
                name_parts.append(surname_elem.text.strip())
            
            if name_parts:
                authors.append(' '.join(name_parts))
        
        return authors
    
    def extract_doi(self, root: ET.Element) -> Optional[str]:
        """Extract DOI"""
        doi_elem = root.find('.//tei:idno[@type="DOI"]', self.ns)
        if doi_elem is not None and doi_elem.text:
            return doi_elem.text.strip()
        return None
    
    def extract_keywords(self, root: ET.Element) -> Optional[str]:
        """Extract keywords"""
        keywords_elem = root.find('.//tei:keywords', self.ns)
        if keywords_elem is not None and keywords_elem.text:
            return keywords_elem.text.strip()
        return None
    
    def extract_abstract(self, root: ET.Element) -> Optional[str]:
        """Extract abstract text"""
        abstract_div = root.find('.//tei:abstract/tei:div', self.ns)
        if abstract_div is not None:
            return self.extract_text_content(abstract_div)
        return None
    
    def extract_body(self, root: ET.Element) -> str:
        """Extract main body content with section structure"""
        body_elem = root.find('.//tei:text/tei:body', self.ns)
        if body_elem is None:
            return ""
        
        content = []
        
        # Process each div (section) in the body
        for div in body_elem.findall('tei:div', self.ns):
            section_content = self.process_section(div)
            if section_content:
                content.append(section_content)
        
        return "\n\n".join(content)
    
    def extract_figures(self, root: ET.Element) -> str:
        """Extract standalone figures and tables from document"""
        content = []
        
        # Find all figure elements in the document (typically after body content)
        figures = root.findall('.//tei:figure', self.ns)
        
        for figure in figures:
            figure_content = self.process_figure(figure)
            if figure_content:
                content.append(figure_content)
        
        return "\n\n".join(content) if content else ""
    
    def extract_back(self, root: ET.Element) -> str:
        """
        Extract back matter content (acknowledgement, data availability, appendices, etc.)
        
        Args:
            root: TEI XML root element
            
        Returns:
            Formatted back matter sections or empty string if none found
        """
        content = []
        
        # Find the back element
        back_elem = root.find('.//tei:text/tei:back', self.ns)
        if back_elem is None:
            return ""
        
        # Process different types of back matter
        for div in back_elem.findall('tei:div', self.ns):
            div_type = div.get('type')
            
            if div_type == 'references':
                # References are handled separately by extract_references
                continue
            else:
                # Handle other types with generic processing
                content.append(self.process_backmatter(div))
        
        # Process funding information if present
        funding_elem = back_elem.find('tei:listOrg[@type="funding"]', self.ns)
        if funding_elem is not None:
            funding_content = self.process_funding_section(funding_elem)
            if funding_content:
                content.append(funding_content)
        
        return "\n\n".join(content) if content else ""
    
    def process_backmatter(self, div: ET.Element) -> str:
        """Process a back matter section with consistent formatting"""
        content = []
                
        # Process nested divs and content
        for child_div in div.findall('.//tei:div', self.ns):
            # Extract section header if present
            head_elem = child_div.find('tei:head', self.ns)
            if head_elem is not None:
                header_text = self.extract_text_content(head_elem)
                if header_text:
                    content.append(f"## {header_text}")
            
            # Extract paragraphs
            for p in child_div.findall('tei:p', self.ns):
                para_text = self.extract_text_content(p)
                if para_text:
                    content.append(para_text)
        
        # Also handle direct paragraphs in the main div
        for p in div.findall('tei:p', self.ns):
            para_text = self.extract_text_content(p)
            if para_text:
                content.append(para_text)
        
        return "\n\n".join(content) if len(content) > 1 else ""
    
    def process_funding_section(self, funding_elem: ET.Element) -> str:
        """Process funding information"""
        content = ["## Funding Information"]
        
        # Extract funding organizations
        for org in funding_elem.findall('tei:org', self.ns):
            org_info = []
            
            # Get grant number
            grant_num = org.find('tei:idno[@type="grant-number"]', self.ns)
            if grant_num is not None and grant_num.text:
                org_info.append(f"Grant Number: {grant_num.text.strip()}")
            
            if org_info:
                content.append("- " + ", ".join(org_info))
        
        return "\n\n".join(content) if len(content) > 1 else ""
    
    def process_section(self, div: ET.Element) -> str:
        """Process a section div element"""
        content = []
        
        # Extract section header
        head_elem = div.find('tei:head', self.ns)
        if head_elem is not None:
            header_text = self.extract_text_content(head_elem)
            if header_text:
                content.append(f"## {header_text}")
                # # Determine header level based on section number
                # section_num = head_elem.get('n', '')
                # if section_num and '.' not in section_num:
                #     content.append(f"## {header_text}")
                # else:
                #     content.append(f"### {header_text}")
        
        # Extract paragraphs
        for p in div.findall('tei:p', self.ns):
            para_text = self.extract_text_content(p)
            if para_text:
                content.append(para_text)
        
        # Process nested subsections
        for subdiv in div.findall('tei:div', self.ns):
            subsection_content = self.process_section(subdiv)
            if subsection_content:
                content.append(subsection_content)
        
        return "\n\n".join(content)
    
    def extract_text_content(self, element: ET.Element) -> str:
        """Extract clean text content from an element, handling references and formatting"""
        if element is None:
            return ""
        
        # Get all text content
        text_parts = []
        
        def extract_recursive(elem):
            if elem.text:
                text_parts.append(elem.text)
            
            for child in elem:
                # Handle references
                if child.tag.endswith('ref'):
                    ref_text = child.text or ""
                    if child.get('target'):
                        # This is a reference citation - keep the text but clean it up
                        text_parts.append(f"[{ref_text}]")
                    else:
                        text_parts.append(ref_text)
                # Handle figures (which includes both tables and regular figures in TEI XML)
                elif child.tag.endswith('figure'):
                    text_parts.append(self.process_figure(child))
                else:
                    extract_recursive(child)
                
                if child.tail:
                    text_parts.append(child.tail)
        
        extract_recursive(element)
        
        # Join and clean up the text
        text = ''.join(text_parts)
        
        # Clean up whitespace
        text = re.sub(r'\s+', ' ', text)
        text = re.sub(r'\n\s*\n', '\n\n', text)
        
        return text.strip()
    
    def process_table(self, table_elem: ET.Element) -> str:
        """
        Process table elements with full structure preservation.
        
        Args:
            table_elem: TEI XML element containing table or figure[@type="table"]
            
        Returns:
            Formatted markdown table or placeholder based on configuration
        """
        # Check configuration - use placeholder if table processing is disabled
        if not self.include_tables or self.table_format == 'placeholder':
            return "\n[TABLE - See original document]\n"
            
        try:
            content = []
            
            # Extract table metadata
            head = table_elem.find('tei:head', self.ns)
            label = table_elem.find('tei:label', self.ns)
            figDesc = table_elem.find('tei:figDesc', self.ns)
            
            # Create table header
            if head is not None and head.text:
                table_title = head.text.strip()
                if label is not None and label.text:
                    content.append(f"## Table {label.text.strip()}: {table_title}")
                else:
                    content.append(f"## {table_title}")
            
            # Add description if available
            if figDesc is not None:
                desc = self.extract_text_content(figDesc)
                if desc:
                    content.append(f"\n**Description:** {desc}\n")
            
            # Process actual table data
            table_data = table_elem.find('tei:table', self.ns)
            if table_data is not None:
                rows = table_data.findall('tei:row', self.ns)
                if rows:
                    markdown_table = self.convert_table_to_markdown(rows)
                    if markdown_table:
                        content.append(markdown_table)
                    else:
                        content.append("\n[TABLE - Structure could not be parsed]\n")
                else:
                    content.append("\n[TABLE - No rows found]\n")
            else:
                content.append("\n[TABLE - No table data found]\n")
            
            return "\n".join(content) if content else "\n[TABLE - Structure could not be parsed]\n"
            
        except Exception as e:
            # Fallback to placeholder on any error
            return f"\n[TABLE - Processing error: {str(e)}]\n"
    
    def convert_table_to_markdown(self, rows: list) -> str:
        """
        Convert TEI table rows to markdown table format.
        
        Args:
            rows: List of TEI row elements
            
        Returns:
            Formatted markdown table string or empty string if conversion fails
        """
        try:
            markdown_rows = []
            
            for i, row in enumerate(rows):
                cells = row.findall('tei:cell', self.ns)
                cell_texts = []
                
                for cell in cells:
                    cell_text = self.extract_text_content(cell).strip()
                    # Escape pipe characters in cell content to prevent markdown table corruption
                    cell_text = cell_text.replace('|', '\\|')
                    # Replace newlines with spaces to keep table structure
                    cell_text = cell_text.replace('\n', ' ')
                    cell_texts.append(cell_text)
                
                # Create markdown table row
                if cell_texts:
                    markdown_rows.append('| ' + ' | '.join(cell_texts) + ' |')
                    
                    # Add separator after header row (first row)
                    if i == 0:
                        separator = '|' + '---|' * len(cell_texts)
                        markdown_rows.append(separator)
            
            return '\n'.join(markdown_rows) if markdown_rows else ""
            
        except Exception as e:
            # Return empty string on conversion error - caller will handle fallback
            return ""
    
    def process_figure(self, figure_elem: ET.Element) -> str:
        """
        Process figure elements with complete metadata extraction.
        
        Args:
            figure_elem: TEI XML element containing figure data
            
        Returns:
            Formatted figure information or placeholder based on configuration
        """
        # Check if this is actually a table (GROBID uses figure[@type="table"])
        if figure_elem.get('type') == 'table':
            return self.process_table(figure_elem)
        
        # Check configuration - use placeholder if figure processing is disabled  
        if not self.include_figures or self.figure_format == 'placeholder':
            return "\n[FIGURE - See original document]\n"
            
        try:
            content = []
            
            # Extract figure metadata
            head = figure_elem.find('tei:head', self.ns)
            label = figure_elem.find('tei:label', self.ns)
            figDesc = figure_elem.find('tei:figDesc', self.ns)
            graphic = figure_elem.find('tei:graphic', self.ns)
            
            # Create figure header
            if head is not None and head.text:
                figure_title = head.text.strip()
                if label is not None and label.text:
                    content.append(f"## Figure {label.text.strip()}: {figure_title}")
                else:
                    content.append(f"## {figure_title}")
            elif label is not None and label.text:
                content.append(f"## Figure {label.text.strip()}")
            
            # Add image reference if available
            if graphic is not None:
                image_url = graphic.get('url', '')
                if image_url:
                    alt_text = f"Figure {label.text if label is not None and label.text else ''}"
                    content.append(f"\n![{alt_text}]({image_url})\n")
            
            # Add description
            if figDesc is not None:
                desc = self.extract_text_content(figDesc)
                if desc:
                    content.append(f"**Description:** {desc}")
            
            return "\n".join(content) if content else "\n[FIGURE - No content found]\n"
            
        except Exception as e:
            # Fallback to placeholder on any error
            return f"\n[FIGURE - Processing error: {str(e)}]\n"
    
    def extract_references(self, root: ET.Element) -> List[str]:
        """Extract bibliography references"""
        references = []
        
        # Look for biblStruct elements in the back matter
        bibl_structs = root.findall('.//tei:back//tei:biblStruct', self.ns)
        
        for bibl in bibl_structs:
            ref_text = self.format_reference(bibl)
            if ref_text:
                references.append(ref_text)
        
        return references
    
    def format_reference(self, bibl_struct: ET.Element) -> str:
        """Format a single bibliographic reference"""
        parts = []
        
        # Extract authors
        authors = []
        author_elems = bibl_struct.findall('.//tei:author/tei:persName', self.ns)
        for author in author_elems:
            name = self.extract_text_content(author)
            if name:
                authors.append(name)
        
        if authors:
            if len(authors) == 1:
                parts.append(authors[0])
            elif len(authors) <= 3:
                parts.append(', '.join(authors[:-1]) + ' and ' + authors[-1])
            else:
                parts.append(authors[0] + ' et al.')
        
        # Extract title
        title_elem = bibl_struct.find('.//tei:title', self.ns)
        if title_elem is not None:
            title = self.extract_text_content(title_elem)
            if title:
                parts.append(f'"{title}"')
        
        # Extract journal/publication info
        monogr = bibl_struct.find('.//tei:monogr', self.ns)
        if monogr is not None:
            journal_elem = monogr.find('tei:title', self.ns)
            if journal_elem is not None:
                journal = self.extract_text_content(journal_elem)
                if journal:
                    parts.append(f"*{journal}*")
            
            # Extract publication year
            date_elem = monogr.find('.//tei:date', self.ns)
            if date_elem is not None and date_elem.get('when'):
                year = date_elem.get('when')
                parts.append(f"({year})")
        
        return '. '.join(parts) + '.' if parts else ""


def main():
    """Main entry point for the CLI application."""
    args = set_args()
    
    # Create converter with user configuration
    converter = TEIToMarkdownConverter(
        include_tables=args.include_tables,
        include_figures=args.include_figures,
        table_format=args.table_format,
        figure_format=args.figure_format,
        include_bib=args.include_bib,
        include_backmatter=args.include_backmatter
    )
    
    input_files = list(args.input_dir.glob('*.xml'))

    if not input_files:
        raise RuntimeError(f"No XML files found in {args.input_dir}")

    output_dir = Path(args.output_dir) if args.output_dir else args.input_dir
    output_dir.mkdir(parents=True, exist_ok=True)
    
    c = 0
    for input_file in tqdm(input_files, desc="Processing TEI files", total=len(input_files)):
        output_file = output_dir / input_file.name.replace('.tei.xml', '.md')
        
        if output_file.exists() and not args.force:
            print(f"Skipping {input_file} -> {output_file} (already exists)")
            continue
        
        try:
            markdown_content = converter.parse_tei_file(str(input_file))
            
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(markdown_content)
            c += 1   
        except Exception as e:
            print(f"Error processing {input_file}: {e}")

    print(f"Converted {c}/{len(input_files)} files.")


if __name__ == "__main__":
    main()
